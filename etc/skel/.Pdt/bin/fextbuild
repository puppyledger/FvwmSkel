#! /usr/bin/perl 

# DEPRECATED: See qmake

use Cwd qw(cwd);
use Sort::Naturally qw(nsort);
use strict;

# fext is the file extension, which designates
# what type of script it is and allows us to
# distinguish between them.

my $fext     = shift @ARGV;
my $basepath = shift @ARGV;
chomp $fext;
chomp $basepath;
die("usage: fext <fileextension>") unless length $fext;

my @file;       # current working file list
my @batfile;    # compendium of scripts to run

# get all the convention complying directory names

@file = cwd2file();                              #
@file = nsort( is_dir( is_relevant(@file) ) );

foreach my $S (@file) {                          # subdir
   my $C = cwd();                                # current dir
   my $T = $C . '/' . $S;                        # fqtdir
   next unless chdir($T);                        # change to the target directory
   my @sfile = nsort( is_fextexec( $fext, is_relevant( cwd2file() ) ) );
   foreach $b (@sfile) {
      push @batfile, fn2bat( $T, $b, $basepath );
   }
   chdir('../');
}

print '#! /bin/bash', "\n\n\#Autogenerated with: fextbuild $fext\n\n";
print @batfile;
print "\n\n";

### FUNCTIONS

sub cwd2file {
   my $cwd = cwd();
   opendir( HERE, $cwd );
   my @file = readdir(HERE);
   closedir(HERE);
   return @file;
}

sub fn2bat { # make a bashable cd up/run/down loop

   my $line;

   if ( length( $_[ 2 ] ) ) {
      $line = "cd " . $_[ 0 ] . '; ./' . $_[ 1 ] . " \'" . $_[ 2 ] . "\'" . '; cd ../' . "\n";
   } else {
      $line = "cd " . $_[ 0 ] . '; ./' . $_[ 1 ] . '; cd ../' . "\n";
   }

   return $line;
}

sub is_fextexec { # only files that match the fext and are executable
   my $fext = shift;
   my @file = @_;
   for ( my $n = 0 ; $n < scalar(@file) ; $n++ ) {
      next if ( $file[ $n ] =~ /^[A-Z]{1,2}\.$fext$/ && -x $file[ $n ] );
      splice( @file, $n, 1 );
      $n--;
   }
   return (@file);
}

sub is_dir { # only directories that are readable and executable
   my @file = @_;
   for ( my $n = 0 ; $n < scalar(@file) ; $n++ ) {
      next if ( -d $file[ $n ] && -r $file[ $n ] && -x $file[ $n ] );
      splice( @file, $n, 1 );
      $n--;
   }
   return (@file);
}

# only accept files and directories named:
# <one or two upper single character>.wordcharacters

sub is_relevant { # only files that match naming convention
   my @file = @_;
   for ( my $n = 0 ; $n < scalar(@file) ; $n++ ) {
      next if $file[ $n ] =~ /^[A-Z]{1,2}\.\w+$/;
      splice( @file, $n, 1 );
      $n--;
   }
   return @file;
}

