package Pdt::SeePack;    # EXPORTONLY

# #
my $VERSION = '2018-04-13.07-04-00.EDT';

#: Read perl package files, extract data in a variety of formats.

use Sort::Naturally qw(nsort);
use Exporter;
our @ISA = qw(Exporter);

# autogenerated with :r ! cbexport

our @EXPORT = qw(format_header_comment format_method_comment seefn seeheaderreport seemethod seemethodhash seemethodreport seepack seepack_swrite);

our %EXPORT_TAGS =
  ( 'all' => [ qw(format_header_comment format_method_comment seefn seeheaderreport seemethod seemethodhash seemethodreport seepack seepack_swrite) ] );

use strict;

sub seepack { # reads the first line of a file, and extracts the package
   my $fn         = shift; # 
   my $noexporter = shift; # ignore packages flagged as EXPORTONLY on the package line

   my $foundexport = 0 ;
   return undef unless ( -r $fn ) ;

   open( FN, $fn );
   my $line = readline(FN) || die( "$fn", '... file not found.' );
   close(FN);
   chomp $line;

   unless ( $line =~ /package/ ) {
      warn('not a package?');
      return undef;
   }

   # exporter packages don't try and register for factories

   if ( $line =~ /EXPORTONLY/ && $noexporter ) {
      $foundexport = 1;
   }

   # record type objects also don't try and register for factories
   # this string format is prefered, and "EXPORTONLY" is deprecated
   # as SKIPFACTORY will work for both cases.

   if ( $line =~ /SKIPFACTORY/ && $noexporter ) {
      $foundexport = 1;
   }

   $line =~ s/^\s*package\s*//;
   $line =~ s/\#.*$//;    # remove comments
   $line =~ s/\;.*//g;    #  remove all but the package name
   $line =~ s/\s+//g;     #

   if ($foundexport) {
      warn "ignoring exporter or skippable class $line";
      return undef;
   }

   return $line;
}

sub seemethod { # read a package file, return a list of methods.
   my $fn = shift;
   return undef unless ( -r $fn );

   my @M = &seemethodhash($fn);
   my @m;

   foreach (@M) {
      push @m, $_->{'method'};
   }

   @m = nsort(@m);

   return @m;
}

sub seemethodreport { # read a package file, return a report of methods including comments
   my $fn = shift;
   return undef unless ( -r $fn );
   my @M = &seemethodhash($fn);
   my @m;

   my %index;
   my $n = 0;

   foreach (@M) {
      push @m, $_->{'method'};
      $index{ $_->{'method'} } = $_;
      $n++;
   }

   @m = nsort(@m);

   my $R;    # report

   foreach (@m) {
      $R .= &format_method_comment( $index{$_} );
   }

   return $R;
}

sub seeheaderreport { # read up to 40 lines of the file, and report comments preceded by #:
   my $fn = shift;

   return undef unless ( -r $fn );
   open( FN, $fn ) || die("unable to open $fn");

   my @R;

   my $n = 0;

   while (<FN>) {

      last if $n > 40;

      if ( $_ =~ /^\#\:/ ) {
         $_ =~ s/^\#\:\s*//;
         chomp $_;
         push @R, $_;
      }

      $n++;
   }

   close(FN);

   return format_header_comment(@R);
}

sub seemethodhash { # read a package file, return an array of hashes (method => ?, comment => ?)
   my $fn = shift;

   return undef unless ( -r $fn );
   open( FN, $fn ) || die("unable to open $fn");

   my @M;

   while (<FN>) {
      last if ( $_ =~ /^\_\_DATA\_\_/ );    # this bailout should let us function inside templates.
      if ( $_ =~ /^sub/ ) {
         chomp;
         my $m = {};
         $m->{'comment'} = $_;
         $m->{'method'}  = $_;

         unless ( $m->{'comment'} =~ /\#/ ) {
            $m->{'comment'} = "undocumented.";
         } else {
            $m->{'comment'} =~ s/^sub\s+[\w\_]+\s*\{\s*\#//;
         }

         $m->{'method'} =~ s/sub\s+(\w+)\s*\{.*/$1/;
         push @M, $m;
      }
   }

   close(FN);

   return @M;
}

sub format_method_comment { # format for seemethodhash
   my $m = shift;
   $_ = seepack_swrite( <<'SWRITE', $m->{'method'}, $m->{'comment'} );
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
	@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
SWRITE
   return $_;
}

sub format_header_comment { # one paragraph format
   my $r = seepack_swrite( <<'SWRITE', @_ );
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
SWRITE

   my @R = split( /\n/, $r );

   # delete empty lines. We get one paragraph only.

   for ( my $n = 0 ; $n < scalar(@R) ; $n++ ) {
      unless ( $R[ $n ] =~ /\w+/ ) {
         splice( @R, $n, 1 );
         $n--;
      }
   }

   $r = join "\n", ( "", @R, "", "" );

   return $r;
}

sub seepack_swrite { # swrite, from the camel book
   my $format = shift;
   $^A = "";
   formline( $format, @_ );
   return $^A;
}

sub seefn { # get a project filename by class
   my $class = shift;

   my $dir = $ENV{'PDT_LIB_PATH'};
   die("no active project defined") unless length($dir);

   $dir =~ s/[\/\s]+$//g;
   $dir .= '/';

   chomp $class;
   $class =~ s/\s+//g;
   $class =~ s/\:\:/\//g;
   $class .= '.pm';

   $dir .= $class;

   return $dir;
}

1;
