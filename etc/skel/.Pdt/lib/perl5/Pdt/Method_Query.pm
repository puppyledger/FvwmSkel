package Pdt::Method_Query;

# #
my $VERSION = '2018-04-13.07-04-00.EDT';

our @ISA = qw(Exporter);
use Pdt::L;
push @ISA, qw(Pdt::L);
our @EXPORT = qw($T);
our $T;
use strict;

### CALLBACKS

sub cbtask {    # :C cbtask (autogenerated code)
   my $self = shift;

   # complex instructions for template fields. These functions typically provide
   # complex instructions or examples for user input for template fields.

   my $cbtask = {};

   $cbtask->{'c_dbi_method'} = sub { shift; $self->c_dbi_method(@_); };

   return $cbtask;
}

sub cbtalias {    # :C cbtalias (autogenerated code)
   my $self = shift;

   # post processing callback map for Pdt::L and Pdt::T derived classes.
   # these are post processing methods for user input, which is typically
   # substitution and aliasesing.
   # ignores: ^_, ^do, ^cb, ^callback, ^new

   my $cbtalias = {};
   $cbtalias->{'b_sqlquery'}   = sub { shift; $self->_b_sqlquery(@_); };
   $cbtalias->{'c_dbi_method'} = sub { shift; $self->_c_dbi_method(@_); };

   return ($cbtalias);
}

### METHODS

sub c_dbi_method {    # question dialog
   my $self = shift;
   my $R    = <<"MYDOCUMENT";
Which style of DBI method: 
a) execute()					# just do it and return success 
b) fetchrow_hashref() 		# return one row as a hash reference.   
c) fetchall_arrayref({})	# return all rows in an array of hashes, as a reference.  
d) fetchrow_array([0])		# return an array with one value
e) fetchall_array([0])		# return a single column
MYDOCUMENT
   return $R;
}

sub _c_dbi_method {    # content processing
   my $self   = shift;
   my $letter = shift;
   my %fpairs = @_;

   chomp $letter;

   my $classmap = {
      'a' => 'Pdt::Method_Query::Execute',
      'b' => 'Pdt::Method_Query::OneHash',
      'c' => 'Pdt::Method_Query::AllHash',
      'd' => 'Pdt::Method_Query::OneVal',
      'e' => 'Pdt::Method_Query::OneCol'
   };

   my $sc = $classmap->{$letter};
   return undef unless length($sc);

   my $ST;    # subtemplate
   my $r;     # report
   my $stblock = "use $sc\;";
   $stblock .= "\$ST \= $sc\-\>new\(\%fpairs\)\;";
   $stblock .= "\$r \= \$ST\-\>output\(\)\;";
   eval($stblock);

   return $@ if $@;

   return $r;
}

sub _b_sqlquery {    # alias string TABLENAME and RECORDIDNAME to appropriate values.
   my $self   = shift;
   my $string = shift;

   my $tablename    = '$_[0]->{\'_tablename\'}';
   my $recordidname = '$_[0]->{\'_recordidname\'}';

   $string =~ s/TABLENAME/$tablename/gi;
   $string =~ s/RECORDIDNAME/$recordidname/gi;

   # warn "IN TEMPLATE FUNCTION" ;
   # warn $string ;

   return $string;
}

1;

__DATA__ 
sub <TMPL_VAR NAME=a_methodname> { # <TMPL_VAR NAME=e_method_brief_description> 
<TMPL_VAR NAME=c_dbi_method>
}       

sub _<TMPL_VAR NAME=a_methodname> { # <TMPL_VAR NAME=b_sqlquery>     
   return $_[ 0 ]->{'_<TMPL_VAR NAME=a_methodname>'} unless $_[ 1 ];
   $_[ 0 ]->{'_<TMPL_VAR NAME=a_methodname>'} = $_[ 0 ]->{'db_handle'}->prepare("<TMPL_VAR NAME=b_sqlquery>") ;
	return 1 ; 
}
