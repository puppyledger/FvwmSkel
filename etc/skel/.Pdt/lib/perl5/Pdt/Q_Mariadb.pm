package Pdt::Q_Mariadb ;

#: Database handle constructor. This constructor is generally inherited
#: with new() run as an initialization function of the deriving class.
#: It can set a database handle for sharing with the setpublic function
#: and it can retrieve a database handle that was shared with the get
#: public function. It can also connect and disconnect itself.
#: General usage is to use it then:
#: $self = Pdt::Q->new('getpublic' => [\$dbhandle, \$dbflag])
#: which gives the constructing class a shared database handle,
#: and a shared connection flag. set public, exports to the
#: requested reference instead. Database parameters are configurable
#: in new(), and connection status can be managed with isconnected,
#: connect, and disconnect.

my $VERSION = '11.1';    # this version is for SQLite.
$ENV{'DBI_DRIVER'} = 'Mariadb';

use Exporter;
use Data::Dumper;
use DBI qw(:sql_types);
use DBD::SQLite qw(:pg_types);
use Pdt::O qw(:all);

our @EXPORT = qw(AUTOLITH PLUROLITH DUMPREGISTRY DUMPSELF COLLAPSE AUTOLOAD);
our %EXPORT_TAGS = ( 'all' => [ qw(AUTOLITH PLUROLITH DUMPREGISTRY DUMPSELF COLLAPSE AUTOLOAD) ] );

our @ISA = qw(Pdt::O Exporter);

use strict;

sub new {    # prototype constructor
   my $class = shift;

   my ( $self, $start ) = AUTOLITH($class);    # registered objects

   # DEFINED PROPERTIES

   $self->{'db_driver'} = undef;               # define the DBD class
   $self->{'db_name'}   = undef;               # database name
   $self->{'db_host'}   = undef;               # database host
   $self->{'db_port'}   = undef;               # database tcp port
   $self->{'db_user'}   = undef;               # database user
   $self->{'db_pass'}   = undef;               # database pass
   $self->{'db_string'} = undef;               # the combined DBI driver string.  (all of the above)

   $self->AUTOPOPULATE(@_);

   if ($start) {

      # setup some callbacks our derived class might want
      $self->cbmap();

   }

   # stick @_ in methods or properties

   $self->AUTOMAP(@_);

   return ( $start, $self );    # pass initialization flag
}

### CALLBACK

sub cbmap {                     # autogenerated with: :r ! cbmap
   my $self = shift;

   # callback map, generally run at constructor time only.
   # The cbmap program ignores methods matching:
   # ^_, ^do, ^cb, ^callback, ^new

   $self->{'cbmap'} = {} unless ( ref( $self->{'cbmap'} ) eq 'HASH' );
   $self->{'cbmap'}->{'connect'}      = sub { shift; return $self->connect(@_); };
   $self->{'cbmap'}->{'db_connected'} = sub { shift; return $self->db_connected(@_); };
   $self->{'cbmap'}->{'db_string'}    = sub { shift; return $self->db_string(@_); };
   $self->{'cbmap'}->{'disconnect'}   = sub { shift; return $self->disconnect(@_); };
   $self->{'cbmap'}->{'getpublic'}    = sub { shift; return $self->getpublic(@_); };
   $self->{'cbmap'}->{'isconnected'}  = sub { shift; return $self->isconnected(@_); };
   $self->{'cbmap'}->{'setpublic'}    = sub { shift; return $self->setpublic(@_); };

   return ( $self->{'cbmap'} );
}

### METHOD

sub db_string {    # assemble basic properties into a query string
   my $self = shift;

   if ( scalar(@_) ) {    # use a fully defined  database driver string

      $self->{'db_string'} = shift @_;

   } else {               # assemble one from properties

      $self->{'db_string'} = $self->{'db_driver'} . ':dbname=' . $self->{'db_name'} . ';host=' . $self->{'db_host'} . ';port=' . $self->{'db_port'};

   }

   return $self->{'db_string'};
}

sub db_connected {        # a flag
   my $self = shift;

   # this function abstracts a flag. The flag may be
   # a pointer to the scalar set in new, or the
   # scalar may be been set elsewhere by get/setpublic

   ${ $self->{'db_connected'} } = $_[ 0 ] if defined $_[ 0 ];
   return ${ $self->{'db_connected'} };
}

sub connect {    # Get a DBI handle, whether it is connected already or not
   my $self = shift;

   return $self->{'db_handle'} if $self->isconnected();
   $self->db_string() unless defined $self->{'db_string'};
   $self->{'db_handle'} = DBI->connect( $self->{'db_string'}, $self->{'db_user'}, $self->{'db_pass'}, { 'RaiseError' => 1, 'AutoCommit' => 1 } );
   $self->db_connected(1);

   return $self->{'db_handle'};
}

sub disconnect {    # disconnect and flag
   my $self = shift;
   $self->{'db_handle'}->disconnect();
   $self->db_connected(0);
   return $self->{'db_connected'};
}

sub isconnected {    # chicken ping
   my $self = shift;
   eval('$self->db_connected($self->{\'db_handle\'}->ping());');
   $self->db_connected(0) if $@;
   return $self->db_connected();
}

sub setpublic {      # recieve references, put our handle and flag in them.
   my $self = shift;

   # we may recieve an array reference or an array

   if ( ref( $_[ 0 ] ) eq "ARRAY" ) {
      @_ = @{ $_[ 0 ] };
   }

   my $handletarget = shift;
   my $contarget    = shift;

   $$handletarget = $self->{'db_handle'};
   $$contarget    = $self->{'db_connected'};
}

sub getpublic {    # recieve references, get our handle and flag from them.
   my $self = shift;

   # we may recieve an array reference or an array

   if ( ref( $_[ 0 ] ) eq "ARRAY" ) {
      @_ = @{ $_[ 0 ] };
   }

   my $handletarget = shift;
   my $contarget    = shift;

   $self->{'db_handle'}    = $handletarget;
   $self->{'db_connected'} = $contarget;
}

1;
